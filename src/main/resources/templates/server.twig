package {{packageName}};

import java.util.Map;
import java.util.HashMap;
import io.grpc.Server;
import io.grpc.ServerBuilder;
import io.grpc.stub.StreamObserver;
import java.io.IOException;
import java.net.ServerSocket;
import java.util.Scanner;
import java.util.concurrent.atomic.AtomicInteger;
import org.javafmi.wrapper.Simulation;
import {{packageName}}.{{fmuName}}Proto.*;

public class {{className}} {


    public static void main(String args[]) throws IOException, InterruptedException {

        final {{className}} server = new {{className}}();
        server.start(findAvailablePort());

        new Thread(() -> {

            Scanner sc = new Scanner(System.in);
            if (sc.hasNext()) {
                server.stop();
            }

        }).start();

        server.blockUntilShutdown();

    }


    private Server server;
    
    private final Simulation referenceFmu;
    private final Map<Integer, Simulation> fmus;
    
    private {{className}}() {

        this.fmus = new HashMap<>();
        this.referenceFmu = new Simulation("{{fmuName}}.fmu");

    }

    private void start(int port) throws IOException {

  

        server = ServerBuilder.forPort(port)
                .addService(new ServiceImpl())
                .build()
                .start();

        System.out.println(port);

    }

    private void stop() {

        if (server != null) {
            server.shutdown();
        }
        disposeFmus();

    }

    private void disposeFmus() {
    
        disposeFmu(referenceFmu);
        for (Simulation fmu : fmus.values()) {
            disposeFmu(fmu);
        }
        fmus.clear();
        
    }

    private void disposeFmu(Simulation fmu) {

        try {
            fmu.terminate();
        } catch (Exception ex) {
        }

    }

    /**
     * Await termination on the main thread since the grpc library uses daemon
     * threads.
     */
    private void blockUntilShutdown() throws InterruptedException {

        if (server != null) {
            server.awaitTermination();
        }

    }

    private static int findAvailablePort() throws IOException {

        try (ServerSocket ss = new ServerSocket(0)) {
            return ss.getLocalPort();
        }
        
    }

    private static void statusReply(org.javafmi.proxy.Status status, StreamObserver<Status> responseObserver) {
        Status reply = Status.newBuilder()
                            .setCode(status.getCode())
                            .setValue(status.getValue())
                            .build();

        responseObserver.onNext(reply);
        responseObserver.onCompleted();
    }

    private static void Read(Simulation fmu, String varName, Var.Builder builder) {

        String typeName = fmu.getModelDescription().getModelVariable(varName).getTypeName();
        switch(typeName) {
            case "Integer": {
                builder.setIntValue(fmu.read(varName).asInteger());
            }
            break;
            case "Real": {
                builder.setRealValue(fmu.read(varName).asDouble());
            }
            break;
            case "String": {
                builder.setStrValue(fmu.read(varName).asString());
            }
            break;
            case "Boolean": {
                builder.setBoolValue(fmu.read(varName).asBoolean());
            }
            break;
        }

    }

     private static org.javafmi.proxy.Status Write(Simulation fmu, VarWrite var) {
        
        String varName = var.getVarName();
        switch (var.getValueCase()) {
            case INTVALUE: {
                return fmu.write(varName).with(var.getIntValue());
            } 
            case REALVALUE: {
                return fmu.write(varName).with(var.getRealValue());
            } 
            case STRVALUE: {
                return fmu.write(varName).with(var.getStrValue());
            } 
            case BOOLVALUE: {
                return fmu.write(varName).with(var.getBoolValue());
            } 
        }

        return null;

    }
    
    private class ServiceImpl extends {{fmuName}}ServiceGrpc.Abstract{{fmuName}}Service {

        private final AtomicInteger refGenerator;

        public ServiceImpl() {
            this.refGenerator = new AtomicInteger(0);
        }

        @Override
        public void createInstance(Empty req, StreamObserver<ModelReference> responseObserver) {
            
            int ref = refGenerator.incrementAndGet();
            fmus.put(ref, new Simulation("{{fmuName}}.fmu"));
            
            ModelReference reply = ModelReference.newBuilder().setRef(ref).build();
            responseObserver.onNext(reply);
            responseObserver.onCompleted();

        }

        @Override 
        public void getModelName(Empty req, StreamObserver<Str> responseObserver) {
            
            String modelName = referenceFmu.getModelDescription().getModelName();
            
            Str reply = Str.newBuilder().setValue(modelName).build();
            responseObserver.onNext(reply);
            responseObserver.onCompleted();

        }

        @Override 
        public void getCurrentTime(ModelReference req, StreamObserver<Real> responseObserver) {
            
            Simulation fmu = fmus.get(req.getRef());
            
            Real reply = Real.newBuilder().setValue(fmu.getCurrentTime()).build();
            responseObserver.onNext(reply);
            responseObserver.onCompleted();

        }

        @Override 
        public void isTerminated(ModelReference req, StreamObserver<Bool> responseObserver) {
            
            Simulation fmu = fmus.get(req.getRef());
            
            Bool reply = Bool.newBuilder().setValue(fmu.isTerminated()).build();
            responseObserver.onNext(reply);
            responseObserver.onCompleted();

        }

        @Override 
        public void read(VarRead req, StreamObserver<Var> responseObserver) {
            
            int ref = req.getRef();
            String varName = req.getVarName();

            Simulation fmu = fmus.get(ref);
            Var.Builder builder = Var.newBuilder();
            Read(fmu, varName, builder);
            Var reply = builder.build();
            
            responseObserver.onNext(reply);
            responseObserver.onCompleted();

        }

        @Override 
        public void write(VarWrite req, StreamObserver<Status> responseObserver) {
            
            Simulation fmu = fmus.get(req.getRef());
            statusReply(Write(fmu, req), responseObserver);

        }

        @Override 
        public void getModelVariableNames(Empty req, StreamObserver<StrList> responseObserver) {
            
            String[] modelVariableNames = referenceFmu.getModelDescription().getModelVariablesNames();
            
            StrList.Builder builder = StrList.newBuilder();
            for (String name : modelVariableNames) {
                builder.addValues(name);
            }

            StrList reply = builder.build();
            responseObserver.onNext(reply);
            responseObserver.onCompleted();

        }

        @Override 
        public void getModelVariables(Empty req, StreamObserver<ScalarVariables> responseObserver) {
            
            org.javafmi.modeldescription.ScalarVariable[] variables = referenceFmu.getModelDescription().getModelVariables();
            
            ScalarVariables.Builder builder = ScalarVariables.newBuilder();
            for (org.javafmi.modeldescription.ScalarVariable var : variables) {
                builder.addValues(ScalarVariable.newBuilder()
                                    .setName(var.getName())
                                    .build());
            }

            ScalarVariables reply = builder.build();
            responseObserver.onNext(reply);
            responseObserver.onCompleted();

        }

        @Override
        public void init(InitRequest req, StreamObserver<Status> responseObserver) {
            
            int ref = req.getRef();
            double start = req.getStart();
            statusReply(fmus.get(ref).init(start), responseObserver);

        }

        @Override
        public void step(StepRequest req, StreamObserver<Status> responseObserver) {

            int ref = req.getRef();
            double dt = req.getDt();
            statusReply(fmus.get(ref).doStep(dt), responseObserver);

        }

        @Override
        public void terminate(TerminateRequest req, StreamObserver<Status> responseObserver) {
            
            int ref = req.getRef();
            try {
                org.javafmi.proxy.Status status = fmus.get(ref).terminate();
                statusReply(status, responseObserver);
            } catch (java.lang.Error ex) {
                statusReply(org.javafmi.proxy.Status.ERROR, responseObserver);
            } finally {
                fmus.remove(ref);
            }

        }

        {{dynamicMethods}}

    }

}
