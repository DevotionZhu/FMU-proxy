/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef definitions_TYPES_H
#define definitions_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/stdcxx.h>

namespace fmuproxy { namespace thrift {

struct Status {
  enum type {
    OK_STATUS = 0,
    WARNING_STATUS = 1,
    DISCARD_STATUS = 2,
    ERROR_STATUS = 3,
    FATAL_STATUS = 4,
    PENDING_STATUS = 5
  };
};

extern const std::map<int, const char*> _Status_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const Status::type& val);

struct Causality {
  enum type {
    INPUT_CAUSALITY = 0,
    OUTPUT_CAUSALITY = 1,
    PARAMETER_CAUSALITY = 2,
    CALCULATED_PARAMETER_CAUSALITY = 3,
    LOCAL_CAUSALITY = 4,
    INDEPENDENT_CAUSALITY = 5
  };
};

extern const std::map<int, const char*> _Causality_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const Causality::type& val);

struct Variability {
  enum type {
    CONSTANT_VARIABILITY = 0,
    FIXED_VARIABILITY = 1,
    CONTINUOUS_VARIABILITY = 2,
    DISCRETE_VARIABILITY = 3,
    TUNABLE_VARIABILITY = 4
  };
};

extern const std::map<int, const char*> _Variability_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const Variability::type& val);

struct Initial {
  enum type {
    EXACT_INITIAL = 0,
    APPROX_INITIAL = 1,
    CALCULATED_INITIAL = 2
  };
};

extern const std::map<int, const char*> _Initial_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const Initial::type& val);

struct DependenciesKind {
  enum type {
    DEPENDENT_KIND = 0,
    CONSTANT_KIND = 1,
    TUNABLE_KIND = 2,
    DISCRETE_KIND = 3
  };
};

extern const std::map<int, const char*> _DependenciesKind_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const DependenciesKind::type& val);

struct VariableNamingConvention {
  enum type {
    FLAT = 0,
    STRUCTURED = 1
  };
};

extern const std::map<int, const char*> _VariableNamingConvention_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const VariableNamingConvention::type& val);

typedef std::vector<class ScalarVariable>  ModelVariables;

class NoSuchFmuException;

class NoSuchVariableException;

class UnsupportedOperationException;

class IntegerAttribute;

class RealAttribute;

class StringAttribute;

class BooleanAttribute;

class EnumerationAttribute;

class ScalarVariableAttribute;

class ScalarVariable;

class Unknown;

class ModelStructure;

class DefaultExperiment;

class StepResult;

class IntegerRead;

class BulkIntegerRead;

class RealRead;

class BulkRealRead;

class StringRead;

class BulkStringRead;

class BooleanRead;

class BulkBooleanRead;

class Solver;

class ModelDescription;

typedef struct _NoSuchFmuException__isset {
  _NoSuchFmuException__isset() : message(false) {}
  bool message :1;
} _NoSuchFmuException__isset;

class NoSuchFmuException : public ::apache::thrift::TException {
 public:

  NoSuchFmuException(const NoSuchFmuException&);
  NoSuchFmuException& operator=(const NoSuchFmuException&);
  NoSuchFmuException() : message() {
  }

  virtual ~NoSuchFmuException() throw();
  std::string message;

  _NoSuchFmuException__isset __isset;

  void __set_message(const std::string& val);

  bool operator == (const NoSuchFmuException & rhs) const
  {
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const NoSuchFmuException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoSuchFmuException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(NoSuchFmuException &a, NoSuchFmuException &b);

std::ostream& operator<<(std::ostream& out, const NoSuchFmuException& obj);

typedef struct _NoSuchVariableException__isset {
  _NoSuchVariableException__isset() : message(false) {}
  bool message :1;
} _NoSuchVariableException__isset;

class NoSuchVariableException : public ::apache::thrift::TException {
 public:

  NoSuchVariableException(const NoSuchVariableException&);
  NoSuchVariableException& operator=(const NoSuchVariableException&);
  NoSuchVariableException() : message() {
  }

  virtual ~NoSuchVariableException() throw();
  std::string message;

  _NoSuchVariableException__isset __isset;

  void __set_message(const std::string& val);

  bool operator == (const NoSuchVariableException & rhs) const
  {
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const NoSuchVariableException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoSuchVariableException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(NoSuchVariableException &a, NoSuchVariableException &b);

std::ostream& operator<<(std::ostream& out, const NoSuchVariableException& obj);

typedef struct _UnsupportedOperationException__isset {
  _UnsupportedOperationException__isset() : message(false) {}
  bool message :1;
} _UnsupportedOperationException__isset;

class UnsupportedOperationException : public ::apache::thrift::TException {
 public:

  UnsupportedOperationException(const UnsupportedOperationException&);
  UnsupportedOperationException& operator=(const UnsupportedOperationException&);
  UnsupportedOperationException() : message() {
  }

  virtual ~UnsupportedOperationException() throw();
  std::string message;

  _UnsupportedOperationException__isset __isset;

  void __set_message(const std::string& val);

  bool operator == (const UnsupportedOperationException & rhs) const
  {
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const UnsupportedOperationException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UnsupportedOperationException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(UnsupportedOperationException &a, UnsupportedOperationException &b);

std::ostream& operator<<(std::ostream& out, const UnsupportedOperationException& obj);

typedef struct _IntegerAttribute__isset {
  _IntegerAttribute__isset() : min(false), max(false), start(false) {}
  bool min :1;
  bool max :1;
  bool start :1;
} _IntegerAttribute__isset;

class IntegerAttribute : public virtual ::apache::thrift::TBase {
 public:

  IntegerAttribute(const IntegerAttribute&);
  IntegerAttribute& operator=(const IntegerAttribute&);
  IntegerAttribute() : min(0), max(0), start(0) {
  }

  virtual ~IntegerAttribute() throw();
  int32_t min;
  int32_t max;
  int32_t start;

  _IntegerAttribute__isset __isset;

  void __set_min(const int32_t val);

  void __set_max(const int32_t val);

  void __set_start(const int32_t val);

  bool operator == (const IntegerAttribute & rhs) const
  {
    if (!(min == rhs.min))
      return false;
    if (!(max == rhs.max))
      return false;
    if (!(start == rhs.start))
      return false;
    return true;
  }
  bool operator != (const IntegerAttribute &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IntegerAttribute & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(IntegerAttribute &a, IntegerAttribute &b);

std::ostream& operator<<(std::ostream& out, const IntegerAttribute& obj);

typedef struct _RealAttribute__isset {
  _RealAttribute__isset() : min(false), max(false), start(false) {}
  bool min :1;
  bool max :1;
  bool start :1;
} _RealAttribute__isset;

class RealAttribute : public virtual ::apache::thrift::TBase {
 public:

  RealAttribute(const RealAttribute&);
  RealAttribute& operator=(const RealAttribute&);
  RealAttribute() : min(0), max(0), start(0) {
  }

  virtual ~RealAttribute() throw();
  double min;
  double max;
  double start;

  _RealAttribute__isset __isset;

  void __set_min(const double val);

  void __set_max(const double val);

  void __set_start(const double val);

  bool operator == (const RealAttribute & rhs) const
  {
    if (!(min == rhs.min))
      return false;
    if (!(max == rhs.max))
      return false;
    if (!(start == rhs.start))
      return false;
    return true;
  }
  bool operator != (const RealAttribute &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const RealAttribute & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(RealAttribute &a, RealAttribute &b);

std::ostream& operator<<(std::ostream& out, const RealAttribute& obj);

typedef struct _StringAttribute__isset {
  _StringAttribute__isset() : start(false) {}
  bool start :1;
} _StringAttribute__isset;

class StringAttribute : public virtual ::apache::thrift::TBase {
 public:

  StringAttribute(const StringAttribute&);
  StringAttribute& operator=(const StringAttribute&);
  StringAttribute() : start() {
  }

  virtual ~StringAttribute() throw();
  std::string start;

  _StringAttribute__isset __isset;

  void __set_start(const std::string& val);

  bool operator == (const StringAttribute & rhs) const
  {
    if (!(start == rhs.start))
      return false;
    return true;
  }
  bool operator != (const StringAttribute &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StringAttribute & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(StringAttribute &a, StringAttribute &b);

std::ostream& operator<<(std::ostream& out, const StringAttribute& obj);

typedef struct _BooleanAttribute__isset {
  _BooleanAttribute__isset() : start(false) {}
  bool start :1;
} _BooleanAttribute__isset;

class BooleanAttribute : public virtual ::apache::thrift::TBase {
 public:

  BooleanAttribute(const BooleanAttribute&);
  BooleanAttribute& operator=(const BooleanAttribute&);
  BooleanAttribute() : start(0) {
  }

  virtual ~BooleanAttribute() throw();
  bool start;

  _BooleanAttribute__isset __isset;

  void __set_start(const bool val);

  bool operator == (const BooleanAttribute & rhs) const
  {
    if (!(start == rhs.start))
      return false;
    return true;
  }
  bool operator != (const BooleanAttribute &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BooleanAttribute & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(BooleanAttribute &a, BooleanAttribute &b);

std::ostream& operator<<(std::ostream& out, const BooleanAttribute& obj);

typedef struct _EnumerationAttribute__isset {
  _EnumerationAttribute__isset() : min(false), max(false), start(false) {}
  bool min :1;
  bool max :1;
  bool start :1;
} _EnumerationAttribute__isset;

class EnumerationAttribute : public virtual ::apache::thrift::TBase {
 public:

  EnumerationAttribute(const EnumerationAttribute&);
  EnumerationAttribute& operator=(const EnumerationAttribute&);
  EnumerationAttribute() : min(0), max(0), start(0) {
  }

  virtual ~EnumerationAttribute() throw();
  int32_t min;
  int32_t max;
  int32_t start;

  _EnumerationAttribute__isset __isset;

  void __set_min(const int32_t val);

  void __set_max(const int32_t val);

  void __set_start(const int32_t val);

  bool operator == (const EnumerationAttribute & rhs) const
  {
    if (!(min == rhs.min))
      return false;
    if (!(max == rhs.max))
      return false;
    if (!(start == rhs.start))
      return false;
    return true;
  }
  bool operator != (const EnumerationAttribute &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const EnumerationAttribute & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(EnumerationAttribute &a, EnumerationAttribute &b);

std::ostream& operator<<(std::ostream& out, const EnumerationAttribute& obj);

typedef struct _ScalarVariableAttribute__isset {
  _ScalarVariableAttribute__isset() : integerAttribute(false), realAttribute(false), stringAttribute(false), booleanAttribute(false), enumerationAttribute(false) {}
  bool integerAttribute :1;
  bool realAttribute :1;
  bool stringAttribute :1;
  bool booleanAttribute :1;
  bool enumerationAttribute :1;
} _ScalarVariableAttribute__isset;

class ScalarVariableAttribute : public virtual ::apache::thrift::TBase {
 public:

  ScalarVariableAttribute(const ScalarVariableAttribute&);
  ScalarVariableAttribute& operator=(const ScalarVariableAttribute&);
  ScalarVariableAttribute() {
  }

  virtual ~ScalarVariableAttribute() throw();
  IntegerAttribute integerAttribute;
  RealAttribute realAttribute;
  StringAttribute stringAttribute;
  BooleanAttribute booleanAttribute;
  EnumerationAttribute enumerationAttribute;

  _ScalarVariableAttribute__isset __isset;

  void __set_integerAttribute(const IntegerAttribute& val);

  void __set_realAttribute(const RealAttribute& val);

  void __set_stringAttribute(const StringAttribute& val);

  void __set_booleanAttribute(const BooleanAttribute& val);

  void __set_enumerationAttribute(const EnumerationAttribute& val);

  bool operator == (const ScalarVariableAttribute & rhs) const
  {
    if (__isset.integerAttribute != rhs.__isset.integerAttribute)
      return false;
    else if (__isset.integerAttribute && !(integerAttribute == rhs.integerAttribute))
      return false;
    if (__isset.realAttribute != rhs.__isset.realAttribute)
      return false;
    else if (__isset.realAttribute && !(realAttribute == rhs.realAttribute))
      return false;
    if (__isset.stringAttribute != rhs.__isset.stringAttribute)
      return false;
    else if (__isset.stringAttribute && !(stringAttribute == rhs.stringAttribute))
      return false;
    if (__isset.booleanAttribute != rhs.__isset.booleanAttribute)
      return false;
    else if (__isset.booleanAttribute && !(booleanAttribute == rhs.booleanAttribute))
      return false;
    if (__isset.enumerationAttribute != rhs.__isset.enumerationAttribute)
      return false;
    else if (__isset.enumerationAttribute && !(enumerationAttribute == rhs.enumerationAttribute))
      return false;
    return true;
  }
  bool operator != (const ScalarVariableAttribute &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ScalarVariableAttribute & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ScalarVariableAttribute &a, ScalarVariableAttribute &b);

std::ostream& operator<<(std::ostream& out, const ScalarVariableAttribute& obj);

typedef struct _ScalarVariable__isset {
  _ScalarVariable__isset() : valueReference(false), name(false), description(false), declaredType(false), initial(false), causality(false), variability(false), attribute(false) {}
  bool valueReference :1;
  bool name :1;
  bool description :1;
  bool declaredType :1;
  bool initial :1;
  bool causality :1;
  bool variability :1;
  bool attribute :1;
} _ScalarVariable__isset;

class ScalarVariable : public virtual ::apache::thrift::TBase {
 public:

  ScalarVariable(const ScalarVariable&);
  ScalarVariable& operator=(const ScalarVariable&);
  ScalarVariable() : valueReference(0), name(), description(), declaredType(), initial((Initial::type)0), causality((Causality::type)0), variability((Variability::type)0) {
  }

  virtual ~ScalarVariable() throw();
  int32_t valueReference;
  std::string name;
  std::string description;
  std::string declaredType;
  Initial::type initial;
  Causality::type causality;
  Variability::type variability;
  ScalarVariableAttribute attribute;

  _ScalarVariable__isset __isset;

  void __set_valueReference(const int32_t val);

  void __set_name(const std::string& val);

  void __set_description(const std::string& val);

  void __set_declaredType(const std::string& val);

  void __set_initial(const Initial::type val);

  void __set_causality(const Causality::type val);

  void __set_variability(const Variability::type val);

  void __set_attribute(const ScalarVariableAttribute& val);

  bool operator == (const ScalarVariable & rhs) const
  {
    if (!(valueReference == rhs.valueReference))
      return false;
    if (!(name == rhs.name))
      return false;
    if (__isset.description != rhs.__isset.description)
      return false;
    else if (__isset.description && !(description == rhs.description))
      return false;
    if (__isset.declaredType != rhs.__isset.declaredType)
      return false;
    else if (__isset.declaredType && !(declaredType == rhs.declaredType))
      return false;
    if (__isset.initial != rhs.__isset.initial)
      return false;
    else if (__isset.initial && !(initial == rhs.initial))
      return false;
    if (__isset.causality != rhs.__isset.causality)
      return false;
    else if (__isset.causality && !(causality == rhs.causality))
      return false;
    if (__isset.variability != rhs.__isset.variability)
      return false;
    else if (__isset.variability && !(variability == rhs.variability))
      return false;
    if (!(attribute == rhs.attribute))
      return false;
    return true;
  }
  bool operator != (const ScalarVariable &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ScalarVariable & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ScalarVariable &a, ScalarVariable &b);

std::ostream& operator<<(std::ostream& out, const ScalarVariable& obj);

typedef struct _Unknown__isset {
  _Unknown__isset() : index(false), dependencies(false), dependenciesKind(false) {}
  bool index :1;
  bool dependencies :1;
  bool dependenciesKind :1;
} _Unknown__isset;

class Unknown : public virtual ::apache::thrift::TBase {
 public:

  Unknown(const Unknown&);
  Unknown& operator=(const Unknown&);
  Unknown() : index(0), dependenciesKind((DependenciesKind::type)0) {
  }

  virtual ~Unknown() throw();
  int32_t index;
  std::vector<int32_t>  dependencies;
  DependenciesKind::type dependenciesKind;

  _Unknown__isset __isset;

  void __set_index(const int32_t val);

  void __set_dependencies(const std::vector<int32_t> & val);

  void __set_dependenciesKind(const DependenciesKind::type val);

  bool operator == (const Unknown & rhs) const
  {
    if (!(index == rhs.index))
      return false;
    if (!(dependencies == rhs.dependencies))
      return false;
    if (!(dependenciesKind == rhs.dependenciesKind))
      return false;
    return true;
  }
  bool operator != (const Unknown &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Unknown & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Unknown &a, Unknown &b);

std::ostream& operator<<(std::ostream& out, const Unknown& obj);

typedef struct _ModelStructure__isset {
  _ModelStructure__isset() : outputs(false), derivatives(false), initialUnknowns(false) {}
  bool outputs :1;
  bool derivatives :1;
  bool initialUnknowns :1;
} _ModelStructure__isset;

class ModelStructure : public virtual ::apache::thrift::TBase {
 public:

  ModelStructure(const ModelStructure&);
  ModelStructure& operator=(const ModelStructure&);
  ModelStructure() {
  }

  virtual ~ModelStructure() throw();
  std::vector<Unknown>  outputs;
  std::vector<Unknown>  derivatives;
  std::vector<Unknown>  initialUnknowns;

  _ModelStructure__isset __isset;

  void __set_outputs(const std::vector<Unknown> & val);

  void __set_derivatives(const std::vector<Unknown> & val);

  void __set_initialUnknowns(const std::vector<Unknown> & val);

  bool operator == (const ModelStructure & rhs) const
  {
    if (!(outputs == rhs.outputs))
      return false;
    if (!(derivatives == rhs.derivatives))
      return false;
    if (!(initialUnknowns == rhs.initialUnknowns))
      return false;
    return true;
  }
  bool operator != (const ModelStructure &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ModelStructure & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ModelStructure &a, ModelStructure &b);

std::ostream& operator<<(std::ostream& out, const ModelStructure& obj);

typedef struct _DefaultExperiment__isset {
  _DefaultExperiment__isset() : startTime(false), stopTime(false), tolerance(false), stepSize(false) {}
  bool startTime :1;
  bool stopTime :1;
  bool tolerance :1;
  bool stepSize :1;
} _DefaultExperiment__isset;

class DefaultExperiment : public virtual ::apache::thrift::TBase {
 public:

  DefaultExperiment(const DefaultExperiment&);
  DefaultExperiment& operator=(const DefaultExperiment&);
  DefaultExperiment() : startTime(0), stopTime(0), tolerance(0), stepSize(0) {
  }

  virtual ~DefaultExperiment() throw();
  double startTime;
  double stopTime;
  double tolerance;
  double stepSize;

  _DefaultExperiment__isset __isset;

  void __set_startTime(const double val);

  void __set_stopTime(const double val);

  void __set_tolerance(const double val);

  void __set_stepSize(const double val);

  bool operator == (const DefaultExperiment & rhs) const
  {
    if (!(startTime == rhs.startTime))
      return false;
    if (!(stopTime == rhs.stopTime))
      return false;
    if (!(tolerance == rhs.tolerance))
      return false;
    if (!(stepSize == rhs.stepSize))
      return false;
    return true;
  }
  bool operator != (const DefaultExperiment &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DefaultExperiment & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DefaultExperiment &a, DefaultExperiment &b);

std::ostream& operator<<(std::ostream& out, const DefaultExperiment& obj);

typedef struct _StepResult__isset {
  _StepResult__isset() : status(false), simulationTime(false) {}
  bool status :1;
  bool simulationTime :1;
} _StepResult__isset;

class StepResult : public virtual ::apache::thrift::TBase {
 public:

  StepResult(const StepResult&);
  StepResult& operator=(const StepResult&);
  StepResult() : status((Status::type)0), simulationTime(0) {
  }

  virtual ~StepResult() throw();
  Status::type status;
  double simulationTime;

  _StepResult__isset __isset;

  void __set_status(const Status::type val);

  void __set_simulationTime(const double val);

  bool operator == (const StepResult & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (!(simulationTime == rhs.simulationTime))
      return false;
    return true;
  }
  bool operator != (const StepResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StepResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(StepResult &a, StepResult &b);

std::ostream& operator<<(std::ostream& out, const StepResult& obj);

typedef struct _IntegerRead__isset {
  _IntegerRead__isset() : value(false), status(false) {}
  bool value :1;
  bool status :1;
} _IntegerRead__isset;

class IntegerRead : public virtual ::apache::thrift::TBase {
 public:

  IntegerRead(const IntegerRead&);
  IntegerRead& operator=(const IntegerRead&);
  IntegerRead() : value(0), status((Status::type)0) {
  }

  virtual ~IntegerRead() throw();
  int32_t value;
  Status::type status;

  _IntegerRead__isset __isset;

  void __set_value(const int32_t val);

  void __set_status(const Status::type val);

  bool operator == (const IntegerRead & rhs) const
  {
    if (!(value == rhs.value))
      return false;
    if (!(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const IntegerRead &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IntegerRead & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(IntegerRead &a, IntegerRead &b);

std::ostream& operator<<(std::ostream& out, const IntegerRead& obj);

typedef struct _BulkIntegerRead__isset {
  _BulkIntegerRead__isset() : value(false), status(false) {}
  bool value :1;
  bool status :1;
} _BulkIntegerRead__isset;

class BulkIntegerRead : public virtual ::apache::thrift::TBase {
 public:

  BulkIntegerRead(const BulkIntegerRead&);
  BulkIntegerRead& operator=(const BulkIntegerRead&);
  BulkIntegerRead() : status((Status::type)0) {
  }

  virtual ~BulkIntegerRead() throw();
  std::vector<int32_t>  value;
  Status::type status;

  _BulkIntegerRead__isset __isset;

  void __set_value(const std::vector<int32_t> & val);

  void __set_status(const Status::type val);

  bool operator == (const BulkIntegerRead & rhs) const
  {
    if (!(value == rhs.value))
      return false;
    if (!(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const BulkIntegerRead &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BulkIntegerRead & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(BulkIntegerRead &a, BulkIntegerRead &b);

std::ostream& operator<<(std::ostream& out, const BulkIntegerRead& obj);

typedef struct _RealRead__isset {
  _RealRead__isset() : value(false), status(false) {}
  bool value :1;
  bool status :1;
} _RealRead__isset;

class RealRead : public virtual ::apache::thrift::TBase {
 public:

  RealRead(const RealRead&);
  RealRead& operator=(const RealRead&);
  RealRead() : value(0), status((Status::type)0) {
  }

  virtual ~RealRead() throw();
  double value;
  Status::type status;

  _RealRead__isset __isset;

  void __set_value(const double val);

  void __set_status(const Status::type val);

  bool operator == (const RealRead & rhs) const
  {
    if (!(value == rhs.value))
      return false;
    if (!(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const RealRead &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const RealRead & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(RealRead &a, RealRead &b);

std::ostream& operator<<(std::ostream& out, const RealRead& obj);

typedef struct _BulkRealRead__isset {
  _BulkRealRead__isset() : value(false), status(false) {}
  bool value :1;
  bool status :1;
} _BulkRealRead__isset;

class BulkRealRead : public virtual ::apache::thrift::TBase {
 public:

  BulkRealRead(const BulkRealRead&);
  BulkRealRead& operator=(const BulkRealRead&);
  BulkRealRead() : status((Status::type)0) {
  }

  virtual ~BulkRealRead() throw();
  std::vector<double>  value;
  Status::type status;

  _BulkRealRead__isset __isset;

  void __set_value(const std::vector<double> & val);

  void __set_status(const Status::type val);

  bool operator == (const BulkRealRead & rhs) const
  {
    if (!(value == rhs.value))
      return false;
    if (!(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const BulkRealRead &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BulkRealRead & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(BulkRealRead &a, BulkRealRead &b);

std::ostream& operator<<(std::ostream& out, const BulkRealRead& obj);

typedef struct _StringRead__isset {
  _StringRead__isset() : value(false), status(false) {}
  bool value :1;
  bool status :1;
} _StringRead__isset;

class StringRead : public virtual ::apache::thrift::TBase {
 public:

  StringRead(const StringRead&);
  StringRead& operator=(const StringRead&);
  StringRead() : value(), status((Status::type)0) {
  }

  virtual ~StringRead() throw();
  std::string value;
  Status::type status;

  _StringRead__isset __isset;

  void __set_value(const std::string& val);

  void __set_status(const Status::type val);

  bool operator == (const StringRead & rhs) const
  {
    if (!(value == rhs.value))
      return false;
    if (!(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const StringRead &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StringRead & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(StringRead &a, StringRead &b);

std::ostream& operator<<(std::ostream& out, const StringRead& obj);

typedef struct _BulkStringRead__isset {
  _BulkStringRead__isset() : value(false), status(false) {}
  bool value :1;
  bool status :1;
} _BulkStringRead__isset;

class BulkStringRead : public virtual ::apache::thrift::TBase {
 public:

  BulkStringRead(const BulkStringRead&);
  BulkStringRead& operator=(const BulkStringRead&);
  BulkStringRead() : status((Status::type)0) {
  }

  virtual ~BulkStringRead() throw();
  std::vector<std::string>  value;
  Status::type status;

  _BulkStringRead__isset __isset;

  void __set_value(const std::vector<std::string> & val);

  void __set_status(const Status::type val);

  bool operator == (const BulkStringRead & rhs) const
  {
    if (!(value == rhs.value))
      return false;
    if (!(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const BulkStringRead &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BulkStringRead & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(BulkStringRead &a, BulkStringRead &b);

std::ostream& operator<<(std::ostream& out, const BulkStringRead& obj);

typedef struct _BooleanRead__isset {
  _BooleanRead__isset() : value(false), status(false) {}
  bool value :1;
  bool status :1;
} _BooleanRead__isset;

class BooleanRead : public virtual ::apache::thrift::TBase {
 public:

  BooleanRead(const BooleanRead&);
  BooleanRead& operator=(const BooleanRead&);
  BooleanRead() : value(0), status((Status::type)0) {
  }

  virtual ~BooleanRead() throw();
  bool value;
  Status::type status;

  _BooleanRead__isset __isset;

  void __set_value(const bool val);

  void __set_status(const Status::type val);

  bool operator == (const BooleanRead & rhs) const
  {
    if (!(value == rhs.value))
      return false;
    if (!(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const BooleanRead &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BooleanRead & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(BooleanRead &a, BooleanRead &b);

std::ostream& operator<<(std::ostream& out, const BooleanRead& obj);

typedef struct _BulkBooleanRead__isset {
  _BulkBooleanRead__isset() : value(false), status(false) {}
  bool value :1;
  bool status :1;
} _BulkBooleanRead__isset;

class BulkBooleanRead : public virtual ::apache::thrift::TBase {
 public:

  BulkBooleanRead(const BulkBooleanRead&);
  BulkBooleanRead& operator=(const BulkBooleanRead&);
  BulkBooleanRead() : status((Status::type)0) {
  }

  virtual ~BulkBooleanRead() throw();
  std::vector<bool>  value;
  Status::type status;

  _BulkBooleanRead__isset __isset;

  void __set_value(const std::vector<bool> & val);

  void __set_status(const Status::type val);

  bool operator == (const BulkBooleanRead & rhs) const
  {
    if (!(value == rhs.value))
      return false;
    if (!(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const BulkBooleanRead &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BulkBooleanRead & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(BulkBooleanRead &a, BulkBooleanRead &b);

std::ostream& operator<<(std::ostream& out, const BulkBooleanRead& obj);

typedef struct _Solver__isset {
  _Solver__isset() : name(false), settings(false) {}
  bool name :1;
  bool settings :1;
} _Solver__isset;

class Solver : public virtual ::apache::thrift::TBase {
 public:

  Solver(const Solver&);
  Solver& operator=(const Solver&);
  Solver() : name(), settings() {
  }

  virtual ~Solver() throw();
  std::string name;
  std::string settings;

  _Solver__isset __isset;

  void __set_name(const std::string& val);

  void __set_settings(const std::string& val);

  bool operator == (const Solver & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(settings == rhs.settings))
      return false;
    return true;
  }
  bool operator != (const Solver &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Solver & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Solver &a, Solver &b);

std::ostream& operator<<(std::ostream& out, const Solver& obj);

typedef struct _ModelDescription__isset {
  _ModelDescription__isset() : fmiVersion(false), modelName(false), guid(false), license(false), copyright(false), author(false), version(false), description(false), generationTool(false), generationDateAndTime(false), defaultExperiment(false), variableNamingConvention(false), modelVariables(false), modelStructure(false), supportsCoSimulation(false), supportsModelExchange(false) {}
  bool fmiVersion :1;
  bool modelName :1;
  bool guid :1;
  bool license :1;
  bool copyright :1;
  bool author :1;
  bool version :1;
  bool description :1;
  bool generationTool :1;
  bool generationDateAndTime :1;
  bool defaultExperiment :1;
  bool variableNamingConvention :1;
  bool modelVariables :1;
  bool modelStructure :1;
  bool supportsCoSimulation :1;
  bool supportsModelExchange :1;
} _ModelDescription__isset;

class ModelDescription : public virtual ::apache::thrift::TBase {
 public:

  ModelDescription(const ModelDescription&);
  ModelDescription& operator=(const ModelDescription&);
  ModelDescription() : fmiVersion(), modelName(), guid(), license(), copyright(), author(), version(), description(), generationTool(), generationDateAndTime(), variableNamingConvention((VariableNamingConvention::type)0), supportsCoSimulation(0), supportsModelExchange(0) {
  }

  virtual ~ModelDescription() throw();
  std::string fmiVersion;
  std::string modelName;
  std::string guid;
  std::string license;
  std::string copyright;
  std::string author;
  std::string version;
  std::string description;
  std::string generationTool;
  std::string generationDateAndTime;
  DefaultExperiment defaultExperiment;
  VariableNamingConvention::type variableNamingConvention;
  ModelVariables modelVariables;
  ModelStructure modelStructure;
  bool supportsCoSimulation;
  bool supportsModelExchange;

  _ModelDescription__isset __isset;

  void __set_fmiVersion(const std::string& val);

  void __set_modelName(const std::string& val);

  void __set_guid(const std::string& val);

  void __set_license(const std::string& val);

  void __set_copyright(const std::string& val);

  void __set_author(const std::string& val);

  void __set_version(const std::string& val);

  void __set_description(const std::string& val);

  void __set_generationTool(const std::string& val);

  void __set_generationDateAndTime(const std::string& val);

  void __set_defaultExperiment(const DefaultExperiment& val);

  void __set_variableNamingConvention(const VariableNamingConvention::type val);

  void __set_modelVariables(const ModelVariables& val);

  void __set_modelStructure(const ModelStructure& val);

  void __set_supportsCoSimulation(const bool val);

  void __set_supportsModelExchange(const bool val);

  bool operator == (const ModelDescription & rhs) const
  {
    if (!(fmiVersion == rhs.fmiVersion))
      return false;
    if (!(modelName == rhs.modelName))
      return false;
    if (!(guid == rhs.guid))
      return false;
    if (__isset.license != rhs.__isset.license)
      return false;
    else if (__isset.license && !(license == rhs.license))
      return false;
    if (__isset.copyright != rhs.__isset.copyright)
      return false;
    else if (__isset.copyright && !(copyright == rhs.copyright))
      return false;
    if (__isset.author != rhs.__isset.author)
      return false;
    else if (__isset.author && !(author == rhs.author))
      return false;
    if (__isset.version != rhs.__isset.version)
      return false;
    else if (__isset.version && !(version == rhs.version))
      return false;
    if (__isset.description != rhs.__isset.description)
      return false;
    else if (__isset.description && !(description == rhs.description))
      return false;
    if (__isset.generationTool != rhs.__isset.generationTool)
      return false;
    else if (__isset.generationTool && !(generationTool == rhs.generationTool))
      return false;
    if (__isset.generationDateAndTime != rhs.__isset.generationDateAndTime)
      return false;
    else if (__isset.generationDateAndTime && !(generationDateAndTime == rhs.generationDateAndTime))
      return false;
    if (__isset.defaultExperiment != rhs.__isset.defaultExperiment)
      return false;
    else if (__isset.defaultExperiment && !(defaultExperiment == rhs.defaultExperiment))
      return false;
    if (__isset.variableNamingConvention != rhs.__isset.variableNamingConvention)
      return false;
    else if (__isset.variableNamingConvention && !(variableNamingConvention == rhs.variableNamingConvention))
      return false;
    if (!(modelVariables == rhs.modelVariables))
      return false;
    if (!(modelStructure == rhs.modelStructure))
      return false;
    if (!(supportsCoSimulation == rhs.supportsCoSimulation))
      return false;
    if (!(supportsModelExchange == rhs.supportsModelExchange))
      return false;
    return true;
  }
  bool operator != (const ModelDescription &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ModelDescription & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ModelDescription &a, ModelDescription &b);

std::ostream& operator<<(std::ostream& out, const ModelDescription& obj);

}} // namespace

#endif
