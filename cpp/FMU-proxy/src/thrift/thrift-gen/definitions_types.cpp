/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "definitions_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace fmuproxy { namespace thrift {

int _kStatusValues[] = {
  Status::OK_STATUS,
  Status::WARNING_STATUS,
  Status::DISCARD_STATUS,
  Status::ERROR_STATUS,
  Status::FATAL_STATUS,
  Status::PENDING_STATUS
};
const char* _kStatusNames[] = {
  "OK_STATUS",
  "WARNING_STATUS",
  "DISCARD_STATUS",
  "ERROR_STATUS",
  "FATAL_STATUS",
  "PENDING_STATUS"
};
const std::map<int, const char*> _Status_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kStatusValues, _kStatusNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const Status::type& val) {
  std::map<int, const char*>::const_iterator it = _Status_VALUES_TO_NAMES.find(val);
  if (it != _Status_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kCausalityValues[] = {
  Causality::INPUT_CAUSALITY,
  Causality::OUTPUT_CAUSALITY,
  Causality::PARAMETER_CAUSALITY,
  Causality::CALCULATED_PARAMETER_CAUSALITY,
  Causality::LOCAL_CAUSALITY,
  Causality::INDEPENDENT_CAUSALITY
};
const char* _kCausalityNames[] = {
  "INPUT_CAUSALITY",
  "OUTPUT_CAUSALITY",
  "PARAMETER_CAUSALITY",
  "CALCULATED_PARAMETER_CAUSALITY",
  "LOCAL_CAUSALITY",
  "INDEPENDENT_CAUSALITY"
};
const std::map<int, const char*> _Causality_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kCausalityValues, _kCausalityNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const Causality::type& val) {
  std::map<int, const char*>::const_iterator it = _Causality_VALUES_TO_NAMES.find(val);
  if (it != _Causality_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kVariabilityValues[] = {
  Variability::CONSTANT_VARIABILITY,
  Variability::FIXED_VARIABILITY,
  Variability::CONTINUOUS_VARIABILITY,
  Variability::DISCRETE_VARIABILITY,
  Variability::TUNABLE_VARIABILITY
};
const char* _kVariabilityNames[] = {
  "CONSTANT_VARIABILITY",
  "FIXED_VARIABILITY",
  "CONTINUOUS_VARIABILITY",
  "DISCRETE_VARIABILITY",
  "TUNABLE_VARIABILITY"
};
const std::map<int, const char*> _Variability_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kVariabilityValues, _kVariabilityNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const Variability::type& val) {
  std::map<int, const char*>::const_iterator it = _Variability_VALUES_TO_NAMES.find(val);
  if (it != _Variability_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kInitialValues[] = {
  Initial::EXACT_INITIAL,
  Initial::APPROX_INITIAL,
  Initial::CALCULATED_INITIAL
};
const char* _kInitialNames[] = {
  "EXACT_INITIAL",
  "APPROX_INITIAL",
  "CALCULATED_INITIAL"
};
const std::map<int, const char*> _Initial_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kInitialValues, _kInitialNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const Initial::type& val) {
  std::map<int, const char*>::const_iterator it = _Initial_VALUES_TO_NAMES.find(val);
  if (it != _Initial_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kDependenciesKindValues[] = {
  DependenciesKind::DEPENDENT_KIND,
  DependenciesKind::CONSTANT_KIND,
  DependenciesKind::TUNABLE_KIND,
  DependenciesKind::DISCRETE_KIND
};
const char* _kDependenciesKindNames[] = {
  "DEPENDENT_KIND",
  "CONSTANT_KIND",
  "TUNABLE_KIND",
  "DISCRETE_KIND"
};
const std::map<int, const char*> _DependenciesKind_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kDependenciesKindValues, _kDependenciesKindNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const DependenciesKind::type& val) {
  std::map<int, const char*>::const_iterator it = _DependenciesKind_VALUES_TO_NAMES.find(val);
  if (it != _DependenciesKind_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kVariableNamingConventionValues[] = {
  VariableNamingConvention::FLAT,
  VariableNamingConvention::STRUCTURED
};
const char* _kVariableNamingConventionNames[] = {
  "FLAT",
  "STRUCTURED"
};
const std::map<int, const char*> _VariableNamingConvention_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kVariableNamingConventionValues, _kVariableNamingConventionNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const VariableNamingConvention::type& val) {
  std::map<int, const char*>::const_iterator it = _VariableNamingConvention_VALUES_TO_NAMES.find(val);
  if (it != _VariableNamingConvention_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}


NoSuchFmuException::~NoSuchFmuException() throw() {
}


void NoSuchFmuException::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const NoSuchFmuException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t NoSuchFmuException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoSuchFmuException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoSuchFmuException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NoSuchFmuException &a, NoSuchFmuException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

NoSuchFmuException::NoSuchFmuException(const NoSuchFmuException& other0) : TException() {
  message = other0.message;
  __isset = other0.__isset;
}
NoSuchFmuException& NoSuchFmuException::operator=(const NoSuchFmuException& other1) {
  message = other1.message;
  __isset = other1.__isset;
  return *this;
}
void NoSuchFmuException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NoSuchFmuException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* NoSuchFmuException::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: NoSuchFmuException";
  }
}


NoSuchVariableException::~NoSuchVariableException() throw() {
}


void NoSuchVariableException::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const NoSuchVariableException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t NoSuchVariableException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoSuchVariableException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoSuchVariableException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NoSuchVariableException &a, NoSuchVariableException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

NoSuchVariableException::NoSuchVariableException(const NoSuchVariableException& other2) : TException() {
  message = other2.message;
  __isset = other2.__isset;
}
NoSuchVariableException& NoSuchVariableException::operator=(const NoSuchVariableException& other3) {
  message = other3.message;
  __isset = other3.__isset;
  return *this;
}
void NoSuchVariableException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NoSuchVariableException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* NoSuchVariableException::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: NoSuchVariableException";
  }
}


UnsupportedOperationException::~UnsupportedOperationException() throw() {
}


void UnsupportedOperationException::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const UnsupportedOperationException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t UnsupportedOperationException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UnsupportedOperationException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UnsupportedOperationException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UnsupportedOperationException &a, UnsupportedOperationException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

UnsupportedOperationException::UnsupportedOperationException(const UnsupportedOperationException& other4) : TException() {
  message = other4.message;
  __isset = other4.__isset;
}
UnsupportedOperationException& UnsupportedOperationException::operator=(const UnsupportedOperationException& other5) {
  message = other5.message;
  __isset = other5.__isset;
  return *this;
}
void UnsupportedOperationException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UnsupportedOperationException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* UnsupportedOperationException::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: UnsupportedOperationException";
  }
}


IntegerAttribute::~IntegerAttribute() throw() {
}


void IntegerAttribute::__set_min(const int32_t val) {
  this->min = val;
}

void IntegerAttribute::__set_max(const int32_t val) {
  this->max = val;
}

void IntegerAttribute::__set_start(const int32_t val) {
  this->start = val;
}
std::ostream& operator<<(std::ostream& out, const IntegerAttribute& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t IntegerAttribute::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->min);
          this->__isset.min = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->max);
          this->__isset.max = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->start);
          this->__isset.start = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t IntegerAttribute::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("IntegerAttribute");

  xfer += oprot->writeFieldBegin("min", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->min);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->max);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->start);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(IntegerAttribute &a, IntegerAttribute &b) {
  using ::std::swap;
  swap(a.min, b.min);
  swap(a.max, b.max);
  swap(a.start, b.start);
  swap(a.__isset, b.__isset);
}

IntegerAttribute::IntegerAttribute(const IntegerAttribute& other6) {
  min = other6.min;
  max = other6.max;
  start = other6.start;
  __isset = other6.__isset;
}
IntegerAttribute& IntegerAttribute::operator=(const IntegerAttribute& other7) {
  min = other7.min;
  max = other7.max;
  start = other7.start;
  __isset = other7.__isset;
  return *this;
}
void IntegerAttribute::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "IntegerAttribute(";
  out << "min=" << to_string(min);
  out << ", " << "max=" << to_string(max);
  out << ", " << "start=" << to_string(start);
  out << ")";
}


RealAttribute::~RealAttribute() throw() {
}


void RealAttribute::__set_min(const double val) {
  this->min = val;
}

void RealAttribute::__set_max(const double val) {
  this->max = val;
}

void RealAttribute::__set_start(const double val) {
  this->start = val;
}
std::ostream& operator<<(std::ostream& out, const RealAttribute& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t RealAttribute::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->min);
          this->__isset.min = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->max);
          this->__isset.max = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->start);
          this->__isset.start = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RealAttribute::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RealAttribute");

  xfer += oprot->writeFieldBegin("min", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->min);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->max);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->start);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RealAttribute &a, RealAttribute &b) {
  using ::std::swap;
  swap(a.min, b.min);
  swap(a.max, b.max);
  swap(a.start, b.start);
  swap(a.__isset, b.__isset);
}

RealAttribute::RealAttribute(const RealAttribute& other8) {
  min = other8.min;
  max = other8.max;
  start = other8.start;
  __isset = other8.__isset;
}
RealAttribute& RealAttribute::operator=(const RealAttribute& other9) {
  min = other9.min;
  max = other9.max;
  start = other9.start;
  __isset = other9.__isset;
  return *this;
}
void RealAttribute::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RealAttribute(";
  out << "min=" << to_string(min);
  out << ", " << "max=" << to_string(max);
  out << ", " << "start=" << to_string(start);
  out << ")";
}


StringAttribute::~StringAttribute() throw() {
}


void StringAttribute::__set_start(const std::string& val) {
  this->start = val;
}
std::ostream& operator<<(std::ostream& out, const StringAttribute& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t StringAttribute::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->start);
          this->__isset.start = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t StringAttribute::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("StringAttribute");

  xfer += oprot->writeFieldBegin("start", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->start);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(StringAttribute &a, StringAttribute &b) {
  using ::std::swap;
  swap(a.start, b.start);
  swap(a.__isset, b.__isset);
}

StringAttribute::StringAttribute(const StringAttribute& other10) {
  start = other10.start;
  __isset = other10.__isset;
}
StringAttribute& StringAttribute::operator=(const StringAttribute& other11) {
  start = other11.start;
  __isset = other11.__isset;
  return *this;
}
void StringAttribute::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "StringAttribute(";
  out << "start=" << to_string(start);
  out << ")";
}


BooleanAttribute::~BooleanAttribute() throw() {
}


void BooleanAttribute::__set_start(const bool val) {
  this->start = val;
}
std::ostream& operator<<(std::ostream& out, const BooleanAttribute& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t BooleanAttribute::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->start);
          this->__isset.start = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BooleanAttribute::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BooleanAttribute");

  xfer += oprot->writeFieldBegin("start", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->start);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BooleanAttribute &a, BooleanAttribute &b) {
  using ::std::swap;
  swap(a.start, b.start);
  swap(a.__isset, b.__isset);
}

BooleanAttribute::BooleanAttribute(const BooleanAttribute& other12) {
  start = other12.start;
  __isset = other12.__isset;
}
BooleanAttribute& BooleanAttribute::operator=(const BooleanAttribute& other13) {
  start = other13.start;
  __isset = other13.__isset;
  return *this;
}
void BooleanAttribute::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BooleanAttribute(";
  out << "start=" << to_string(start);
  out << ")";
}


EnumerationAttribute::~EnumerationAttribute() throw() {
}


void EnumerationAttribute::__set_min(const int32_t val) {
  this->min = val;
}

void EnumerationAttribute::__set_max(const int32_t val) {
  this->max = val;
}

void EnumerationAttribute::__set_start(const int32_t val) {
  this->start = val;
}
std::ostream& operator<<(std::ostream& out, const EnumerationAttribute& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t EnumerationAttribute::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->min);
          this->__isset.min = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->max);
          this->__isset.max = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->start);
          this->__isset.start = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t EnumerationAttribute::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("EnumerationAttribute");

  xfer += oprot->writeFieldBegin("min", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->min);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->max);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->start);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(EnumerationAttribute &a, EnumerationAttribute &b) {
  using ::std::swap;
  swap(a.min, b.min);
  swap(a.max, b.max);
  swap(a.start, b.start);
  swap(a.__isset, b.__isset);
}

EnumerationAttribute::EnumerationAttribute(const EnumerationAttribute& other14) {
  min = other14.min;
  max = other14.max;
  start = other14.start;
  __isset = other14.__isset;
}
EnumerationAttribute& EnumerationAttribute::operator=(const EnumerationAttribute& other15) {
  min = other15.min;
  max = other15.max;
  start = other15.start;
  __isset = other15.__isset;
  return *this;
}
void EnumerationAttribute::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "EnumerationAttribute(";
  out << "min=" << to_string(min);
  out << ", " << "max=" << to_string(max);
  out << ", " << "start=" << to_string(start);
  out << ")";
}


ScalarVariableAttribute::~ScalarVariableAttribute() throw() {
}


void ScalarVariableAttribute::__set_integerAttribute(const IntegerAttribute& val) {
  this->integerAttribute = val;
__isset.integerAttribute = true;
}

void ScalarVariableAttribute::__set_realAttribute(const RealAttribute& val) {
  this->realAttribute = val;
__isset.realAttribute = true;
}

void ScalarVariableAttribute::__set_stringAttribute(const StringAttribute& val) {
  this->stringAttribute = val;
__isset.stringAttribute = true;
}

void ScalarVariableAttribute::__set_booleanAttribute(const BooleanAttribute& val) {
  this->booleanAttribute = val;
__isset.booleanAttribute = true;
}

void ScalarVariableAttribute::__set_enumerationAttribute(const EnumerationAttribute& val) {
  this->enumerationAttribute = val;
__isset.enumerationAttribute = true;
}
std::ostream& operator<<(std::ostream& out, const ScalarVariableAttribute& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ScalarVariableAttribute::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->integerAttribute.read(iprot);
          this->__isset.integerAttribute = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->realAttribute.read(iprot);
          this->__isset.realAttribute = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stringAttribute.read(iprot);
          this->__isset.stringAttribute = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->booleanAttribute.read(iprot);
          this->__isset.booleanAttribute = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->enumerationAttribute.read(iprot);
          this->__isset.enumerationAttribute = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ScalarVariableAttribute::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ScalarVariableAttribute");

  if (this->__isset.integerAttribute) {
    xfer += oprot->writeFieldBegin("integerAttribute", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->integerAttribute.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.realAttribute) {
    xfer += oprot->writeFieldBegin("realAttribute", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->realAttribute.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.stringAttribute) {
    xfer += oprot->writeFieldBegin("stringAttribute", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->stringAttribute.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.booleanAttribute) {
    xfer += oprot->writeFieldBegin("booleanAttribute", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->booleanAttribute.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.enumerationAttribute) {
    xfer += oprot->writeFieldBegin("enumerationAttribute", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->enumerationAttribute.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ScalarVariableAttribute &a, ScalarVariableAttribute &b) {
  using ::std::swap;
  swap(a.integerAttribute, b.integerAttribute);
  swap(a.realAttribute, b.realAttribute);
  swap(a.stringAttribute, b.stringAttribute);
  swap(a.booleanAttribute, b.booleanAttribute);
  swap(a.enumerationAttribute, b.enumerationAttribute);
  swap(a.__isset, b.__isset);
}

ScalarVariableAttribute::ScalarVariableAttribute(const ScalarVariableAttribute& other16) {
  integerAttribute = other16.integerAttribute;
  realAttribute = other16.realAttribute;
  stringAttribute = other16.stringAttribute;
  booleanAttribute = other16.booleanAttribute;
  enumerationAttribute = other16.enumerationAttribute;
  __isset = other16.__isset;
}
ScalarVariableAttribute& ScalarVariableAttribute::operator=(const ScalarVariableAttribute& other17) {
  integerAttribute = other17.integerAttribute;
  realAttribute = other17.realAttribute;
  stringAttribute = other17.stringAttribute;
  booleanAttribute = other17.booleanAttribute;
  enumerationAttribute = other17.enumerationAttribute;
  __isset = other17.__isset;
  return *this;
}
void ScalarVariableAttribute::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ScalarVariableAttribute(";
  out << "integerAttribute="; (__isset.integerAttribute ? (out << to_string(integerAttribute)) : (out << "<null>"));
  out << ", " << "realAttribute="; (__isset.realAttribute ? (out << to_string(realAttribute)) : (out << "<null>"));
  out << ", " << "stringAttribute="; (__isset.stringAttribute ? (out << to_string(stringAttribute)) : (out << "<null>"));
  out << ", " << "booleanAttribute="; (__isset.booleanAttribute ? (out << to_string(booleanAttribute)) : (out << "<null>"));
  out << ", " << "enumerationAttribute="; (__isset.enumerationAttribute ? (out << to_string(enumerationAttribute)) : (out << "<null>"));
  out << ")";
}


ScalarVariable::~ScalarVariable() throw() {
}


void ScalarVariable::__set_valueReference(const int32_t val) {
  this->valueReference = val;
}

void ScalarVariable::__set_name(const std::string& val) {
  this->name = val;
}

void ScalarVariable::__set_description(const std::string& val) {
  this->description = val;
__isset.description = true;
}

void ScalarVariable::__set_declaredType(const std::string& val) {
  this->declaredType = val;
__isset.declaredType = true;
}

void ScalarVariable::__set_initial(const Initial::type val) {
  this->initial = val;
__isset.initial = true;
}

void ScalarVariable::__set_causality(const Causality::type val) {
  this->causality = val;
__isset.causality = true;
}

void ScalarVariable::__set_variability(const Variability::type val) {
  this->variability = val;
__isset.variability = true;
}

void ScalarVariable::__set_attribute(const ScalarVariableAttribute& val) {
  this->attribute = val;
}
std::ostream& operator<<(std::ostream& out, const ScalarVariable& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ScalarVariable::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->valueReference);
          this->__isset.valueReference = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->description);
          this->__isset.description = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->declaredType);
          this->__isset.declaredType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast18;
          xfer += iprot->readI32(ecast18);
          this->initial = (Initial::type)ecast18;
          this->__isset.initial = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast19;
          xfer += iprot->readI32(ecast19);
          this->causality = (Causality::type)ecast19;
          this->__isset.causality = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast20;
          xfer += iprot->readI32(ecast20);
          this->variability = (Variability::type)ecast20;
          this->__isset.variability = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->attribute.read(iprot);
          this->__isset.attribute = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ScalarVariable::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ScalarVariable");

  xfer += oprot->writeFieldBegin("valueReference", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->valueReference);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.description) {
    xfer += oprot->writeFieldBegin("description", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->description);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.declaredType) {
    xfer += oprot->writeFieldBegin("declaredType", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->declaredType);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.initial) {
    xfer += oprot->writeFieldBegin("initial", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32((int32_t)this->initial);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.causality) {
    xfer += oprot->writeFieldBegin("causality", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32((int32_t)this->causality);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.variability) {
    xfer += oprot->writeFieldBegin("variability", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32((int32_t)this->variability);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("attribute", ::apache::thrift::protocol::T_STRUCT, 8);
  xfer += this->attribute.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ScalarVariable &a, ScalarVariable &b) {
  using ::std::swap;
  swap(a.valueReference, b.valueReference);
  swap(a.name, b.name);
  swap(a.description, b.description);
  swap(a.declaredType, b.declaredType);
  swap(a.initial, b.initial);
  swap(a.causality, b.causality);
  swap(a.variability, b.variability);
  swap(a.attribute, b.attribute);
  swap(a.__isset, b.__isset);
}

ScalarVariable::ScalarVariable(const ScalarVariable& other21) {
  valueReference = other21.valueReference;
  name = other21.name;
  description = other21.description;
  declaredType = other21.declaredType;
  initial = other21.initial;
  causality = other21.causality;
  variability = other21.variability;
  attribute = other21.attribute;
  __isset = other21.__isset;
}
ScalarVariable& ScalarVariable::operator=(const ScalarVariable& other22) {
  valueReference = other22.valueReference;
  name = other22.name;
  description = other22.description;
  declaredType = other22.declaredType;
  initial = other22.initial;
  causality = other22.causality;
  variability = other22.variability;
  attribute = other22.attribute;
  __isset = other22.__isset;
  return *this;
}
void ScalarVariable::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ScalarVariable(";
  out << "valueReference=" << to_string(valueReference);
  out << ", " << "name=" << to_string(name);
  out << ", " << "description="; (__isset.description ? (out << to_string(description)) : (out << "<null>"));
  out << ", " << "declaredType="; (__isset.declaredType ? (out << to_string(declaredType)) : (out << "<null>"));
  out << ", " << "initial="; (__isset.initial ? (out << to_string(initial)) : (out << "<null>"));
  out << ", " << "causality="; (__isset.causality ? (out << to_string(causality)) : (out << "<null>"));
  out << ", " << "variability="; (__isset.variability ? (out << to_string(variability)) : (out << "<null>"));
  out << ", " << "attribute=" << to_string(attribute);
  out << ")";
}


Unknown::~Unknown() throw() {
}


void Unknown::__set_index(const int32_t val) {
  this->index = val;
}

void Unknown::__set_dependencies(const std::vector<int32_t> & val) {
  this->dependencies = val;
}

void Unknown::__set_dependenciesKind(const DependenciesKind::type val) {
  this->dependenciesKind = val;
}
std::ostream& operator<<(std::ostream& out, const Unknown& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Unknown::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->index);
          this->__isset.index = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->dependencies.clear();
            uint32_t _size23;
            ::apache::thrift::protocol::TType _etype26;
            xfer += iprot->readListBegin(_etype26, _size23);
            this->dependencies.resize(_size23);
            uint32_t _i27;
            for (_i27 = 0; _i27 < _size23; ++_i27)
            {
              xfer += iprot->readI32(this->dependencies[_i27]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.dependencies = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast28;
          xfer += iprot->readI32(ecast28);
          this->dependenciesKind = (DependenciesKind::type)ecast28;
          this->__isset.dependenciesKind = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Unknown::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Unknown");

  xfer += oprot->writeFieldBegin("index", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->index);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dependencies", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->dependencies.size()));
    std::vector<int32_t> ::const_iterator _iter29;
    for (_iter29 = this->dependencies.begin(); _iter29 != this->dependencies.end(); ++_iter29)
    {
      xfer += oprot->writeI32((*_iter29));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dependenciesKind", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->dependenciesKind);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Unknown &a, Unknown &b) {
  using ::std::swap;
  swap(a.index, b.index);
  swap(a.dependencies, b.dependencies);
  swap(a.dependenciesKind, b.dependenciesKind);
  swap(a.__isset, b.__isset);
}

Unknown::Unknown(const Unknown& other30) {
  index = other30.index;
  dependencies = other30.dependencies;
  dependenciesKind = other30.dependenciesKind;
  __isset = other30.__isset;
}
Unknown& Unknown::operator=(const Unknown& other31) {
  index = other31.index;
  dependencies = other31.dependencies;
  dependenciesKind = other31.dependenciesKind;
  __isset = other31.__isset;
  return *this;
}
void Unknown::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Unknown(";
  out << "index=" << to_string(index);
  out << ", " << "dependencies=" << to_string(dependencies);
  out << ", " << "dependenciesKind=" << to_string(dependenciesKind);
  out << ")";
}


ModelStructure::~ModelStructure() throw() {
}


void ModelStructure::__set_outputs(const std::vector<Unknown> & val) {
  this->outputs = val;
}

void ModelStructure::__set_derivatives(const std::vector<Unknown> & val) {
  this->derivatives = val;
}

void ModelStructure::__set_initialUnknowns(const std::vector<Unknown> & val) {
  this->initialUnknowns = val;
}
std::ostream& operator<<(std::ostream& out, const ModelStructure& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ModelStructure::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->outputs.clear();
            uint32_t _size32;
            ::apache::thrift::protocol::TType _etype35;
            xfer += iprot->readListBegin(_etype35, _size32);
            this->outputs.resize(_size32);
            uint32_t _i36;
            for (_i36 = 0; _i36 < _size32; ++_i36)
            {
              xfer += this->outputs[_i36].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.outputs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->derivatives.clear();
            uint32_t _size37;
            ::apache::thrift::protocol::TType _etype40;
            xfer += iprot->readListBegin(_etype40, _size37);
            this->derivatives.resize(_size37);
            uint32_t _i41;
            for (_i41 = 0; _i41 < _size37; ++_i41)
            {
              xfer += this->derivatives[_i41].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.derivatives = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->initialUnknowns.clear();
            uint32_t _size42;
            ::apache::thrift::protocol::TType _etype45;
            xfer += iprot->readListBegin(_etype45, _size42);
            this->initialUnknowns.resize(_size42);
            uint32_t _i46;
            for (_i46 = 0; _i46 < _size42; ++_i46)
            {
              xfer += this->initialUnknowns[_i46].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.initialUnknowns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ModelStructure::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ModelStructure");

  xfer += oprot->writeFieldBegin("outputs", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->outputs.size()));
    std::vector<Unknown> ::const_iterator _iter47;
    for (_iter47 = this->outputs.begin(); _iter47 != this->outputs.end(); ++_iter47)
    {
      xfer += (*_iter47).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("derivatives", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->derivatives.size()));
    std::vector<Unknown> ::const_iterator _iter48;
    for (_iter48 = this->derivatives.begin(); _iter48 != this->derivatives.end(); ++_iter48)
    {
      xfer += (*_iter48).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("initialUnknowns", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->initialUnknowns.size()));
    std::vector<Unknown> ::const_iterator _iter49;
    for (_iter49 = this->initialUnknowns.begin(); _iter49 != this->initialUnknowns.end(); ++_iter49)
    {
      xfer += (*_iter49).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ModelStructure &a, ModelStructure &b) {
  using ::std::swap;
  swap(a.outputs, b.outputs);
  swap(a.derivatives, b.derivatives);
  swap(a.initialUnknowns, b.initialUnknowns);
  swap(a.__isset, b.__isset);
}

ModelStructure::ModelStructure(const ModelStructure& other50) {
  outputs = other50.outputs;
  derivatives = other50.derivatives;
  initialUnknowns = other50.initialUnknowns;
  __isset = other50.__isset;
}
ModelStructure& ModelStructure::operator=(const ModelStructure& other51) {
  outputs = other51.outputs;
  derivatives = other51.derivatives;
  initialUnknowns = other51.initialUnknowns;
  __isset = other51.__isset;
  return *this;
}
void ModelStructure::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ModelStructure(";
  out << "outputs=" << to_string(outputs);
  out << ", " << "derivatives=" << to_string(derivatives);
  out << ", " << "initialUnknowns=" << to_string(initialUnknowns);
  out << ")";
}


DefaultExperiment::~DefaultExperiment() throw() {
}


void DefaultExperiment::__set_startTime(const double val) {
  this->startTime = val;
}

void DefaultExperiment::__set_stopTime(const double val) {
  this->stopTime = val;
}

void DefaultExperiment::__set_tolerance(const double val) {
  this->tolerance = val;
}

void DefaultExperiment::__set_stepSize(const double val) {
  this->stepSize = val;
}
std::ostream& operator<<(std::ostream& out, const DefaultExperiment& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DefaultExperiment::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->startTime);
          this->__isset.startTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->stopTime);
          this->__isset.stopTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->tolerance);
          this->__isset.tolerance = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->stepSize);
          this->__isset.stepSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DefaultExperiment::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DefaultExperiment");

  xfer += oprot->writeFieldBegin("startTime", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->startTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stopTime", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->stopTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tolerance", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->tolerance);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stepSize", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble(this->stepSize);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DefaultExperiment &a, DefaultExperiment &b) {
  using ::std::swap;
  swap(a.startTime, b.startTime);
  swap(a.stopTime, b.stopTime);
  swap(a.tolerance, b.tolerance);
  swap(a.stepSize, b.stepSize);
  swap(a.__isset, b.__isset);
}

DefaultExperiment::DefaultExperiment(const DefaultExperiment& other52) {
  startTime = other52.startTime;
  stopTime = other52.stopTime;
  tolerance = other52.tolerance;
  stepSize = other52.stepSize;
  __isset = other52.__isset;
}
DefaultExperiment& DefaultExperiment::operator=(const DefaultExperiment& other53) {
  startTime = other53.startTime;
  stopTime = other53.stopTime;
  tolerance = other53.tolerance;
  stepSize = other53.stepSize;
  __isset = other53.__isset;
  return *this;
}
void DefaultExperiment::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DefaultExperiment(";
  out << "startTime=" << to_string(startTime);
  out << ", " << "stopTime=" << to_string(stopTime);
  out << ", " << "tolerance=" << to_string(tolerance);
  out << ", " << "stepSize=" << to_string(stepSize);
  out << ")";
}


StepResult::~StepResult() throw() {
}


void StepResult::__set_status(const Status::type val) {
  this->status = val;
}

void StepResult::__set_simulationTime(const double val) {
  this->simulationTime = val;
}
std::ostream& operator<<(std::ostream& out, const StepResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t StepResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast54;
          xfer += iprot->readI32(ecast54);
          this->status = (Status::type)ecast54;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->simulationTime);
          this->__isset.simulationTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t StepResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("StepResult");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("simulationTime", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->simulationTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(StepResult &a, StepResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.simulationTime, b.simulationTime);
  swap(a.__isset, b.__isset);
}

StepResult::StepResult(const StepResult& other55) {
  status = other55.status;
  simulationTime = other55.simulationTime;
  __isset = other55.__isset;
}
StepResult& StepResult::operator=(const StepResult& other56) {
  status = other56.status;
  simulationTime = other56.simulationTime;
  __isset = other56.__isset;
  return *this;
}
void StepResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "StepResult(";
  out << "status=" << to_string(status);
  out << ", " << "simulationTime=" << to_string(simulationTime);
  out << ")";
}


IntegerRead::~IntegerRead() throw() {
}


void IntegerRead::__set_value(const int32_t val) {
  this->value = val;
}

void IntegerRead::__set_status(const Status::type val) {
  this->status = val;
}
std::ostream& operator<<(std::ostream& out, const IntegerRead& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t IntegerRead::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast57;
          xfer += iprot->readI32(ecast57);
          this->status = (Status::type)ecast57;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t IntegerRead::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("IntegerRead");

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(IntegerRead &a, IntegerRead &b) {
  using ::std::swap;
  swap(a.value, b.value);
  swap(a.status, b.status);
  swap(a.__isset, b.__isset);
}

IntegerRead::IntegerRead(const IntegerRead& other58) {
  value = other58.value;
  status = other58.status;
  __isset = other58.__isset;
}
IntegerRead& IntegerRead::operator=(const IntegerRead& other59) {
  value = other59.value;
  status = other59.status;
  __isset = other59.__isset;
  return *this;
}
void IntegerRead::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "IntegerRead(";
  out << "value=" << to_string(value);
  out << ", " << "status=" << to_string(status);
  out << ")";
}


BulkIntegerRead::~BulkIntegerRead() throw() {
}


void BulkIntegerRead::__set_value(const std::vector<int32_t> & val) {
  this->value = val;
}

void BulkIntegerRead::__set_status(const Status::type val) {
  this->status = val;
}
std::ostream& operator<<(std::ostream& out, const BulkIntegerRead& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t BulkIntegerRead::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->value.clear();
            uint32_t _size60;
            ::apache::thrift::protocol::TType _etype63;
            xfer += iprot->readListBegin(_etype63, _size60);
            this->value.resize(_size60);
            uint32_t _i64;
            for (_i64 = 0; _i64 < _size60; ++_i64)
            {
              xfer += iprot->readI32(this->value[_i64]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast65;
          xfer += iprot->readI32(ecast65);
          this->status = (Status::type)ecast65;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BulkIntegerRead::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BulkIntegerRead");

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->value.size()));
    std::vector<int32_t> ::const_iterator _iter66;
    for (_iter66 = this->value.begin(); _iter66 != this->value.end(); ++_iter66)
    {
      xfer += oprot->writeI32((*_iter66));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BulkIntegerRead &a, BulkIntegerRead &b) {
  using ::std::swap;
  swap(a.value, b.value);
  swap(a.status, b.status);
  swap(a.__isset, b.__isset);
}

BulkIntegerRead::BulkIntegerRead(const BulkIntegerRead& other67) {
  value = other67.value;
  status = other67.status;
  __isset = other67.__isset;
}
BulkIntegerRead& BulkIntegerRead::operator=(const BulkIntegerRead& other68) {
  value = other68.value;
  status = other68.status;
  __isset = other68.__isset;
  return *this;
}
void BulkIntegerRead::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BulkIntegerRead(";
  out << "value=" << to_string(value);
  out << ", " << "status=" << to_string(status);
  out << ")";
}


RealRead::~RealRead() throw() {
}


void RealRead::__set_value(const double val) {
  this->value = val;
}

void RealRead::__set_status(const Status::type val) {
  this->status = val;
}
std::ostream& operator<<(std::ostream& out, const RealRead& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t RealRead::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast69;
          xfer += iprot->readI32(ecast69);
          this->status = (Status::type)ecast69;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RealRead::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RealRead");

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RealRead &a, RealRead &b) {
  using ::std::swap;
  swap(a.value, b.value);
  swap(a.status, b.status);
  swap(a.__isset, b.__isset);
}

RealRead::RealRead(const RealRead& other70) {
  value = other70.value;
  status = other70.status;
  __isset = other70.__isset;
}
RealRead& RealRead::operator=(const RealRead& other71) {
  value = other71.value;
  status = other71.status;
  __isset = other71.__isset;
  return *this;
}
void RealRead::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RealRead(";
  out << "value=" << to_string(value);
  out << ", " << "status=" << to_string(status);
  out << ")";
}


BulkRealRead::~BulkRealRead() throw() {
}


void BulkRealRead::__set_value(const std::vector<double> & val) {
  this->value = val;
}

void BulkRealRead::__set_status(const Status::type val) {
  this->status = val;
}
std::ostream& operator<<(std::ostream& out, const BulkRealRead& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t BulkRealRead::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->value.clear();
            uint32_t _size72;
            ::apache::thrift::protocol::TType _etype75;
            xfer += iprot->readListBegin(_etype75, _size72);
            this->value.resize(_size72);
            uint32_t _i76;
            for (_i76 = 0; _i76 < _size72; ++_i76)
            {
              xfer += iprot->readDouble(this->value[_i76]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast77;
          xfer += iprot->readI32(ecast77);
          this->status = (Status::type)ecast77;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BulkRealRead::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BulkRealRead");

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->value.size()));
    std::vector<double> ::const_iterator _iter78;
    for (_iter78 = this->value.begin(); _iter78 != this->value.end(); ++_iter78)
    {
      xfer += oprot->writeDouble((*_iter78));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BulkRealRead &a, BulkRealRead &b) {
  using ::std::swap;
  swap(a.value, b.value);
  swap(a.status, b.status);
  swap(a.__isset, b.__isset);
}

BulkRealRead::BulkRealRead(const BulkRealRead& other79) {
  value = other79.value;
  status = other79.status;
  __isset = other79.__isset;
}
BulkRealRead& BulkRealRead::operator=(const BulkRealRead& other80) {
  value = other80.value;
  status = other80.status;
  __isset = other80.__isset;
  return *this;
}
void BulkRealRead::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BulkRealRead(";
  out << "value=" << to_string(value);
  out << ", " << "status=" << to_string(status);
  out << ")";
}


StringRead::~StringRead() throw() {
}


void StringRead::__set_value(const std::string& val) {
  this->value = val;
}

void StringRead::__set_status(const Status::type val) {
  this->status = val;
}
std::ostream& operator<<(std::ostream& out, const StringRead& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t StringRead::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast81;
          xfer += iprot->readI32(ecast81);
          this->status = (Status::type)ecast81;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t StringRead::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("StringRead");

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(StringRead &a, StringRead &b) {
  using ::std::swap;
  swap(a.value, b.value);
  swap(a.status, b.status);
  swap(a.__isset, b.__isset);
}

StringRead::StringRead(const StringRead& other82) {
  value = other82.value;
  status = other82.status;
  __isset = other82.__isset;
}
StringRead& StringRead::operator=(const StringRead& other83) {
  value = other83.value;
  status = other83.status;
  __isset = other83.__isset;
  return *this;
}
void StringRead::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "StringRead(";
  out << "value=" << to_string(value);
  out << ", " << "status=" << to_string(status);
  out << ")";
}


BulkStringRead::~BulkStringRead() throw() {
}


void BulkStringRead::__set_value(const std::vector<std::string> & val) {
  this->value = val;
}

void BulkStringRead::__set_status(const Status::type val) {
  this->status = val;
}
std::ostream& operator<<(std::ostream& out, const BulkStringRead& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t BulkStringRead::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->value.clear();
            uint32_t _size84;
            ::apache::thrift::protocol::TType _etype87;
            xfer += iprot->readListBegin(_etype87, _size84);
            this->value.resize(_size84);
            uint32_t _i88;
            for (_i88 = 0; _i88 < _size84; ++_i88)
            {
              xfer += iprot->readString(this->value[_i88]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast89;
          xfer += iprot->readI32(ecast89);
          this->status = (Status::type)ecast89;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BulkStringRead::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BulkStringRead");

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->value.size()));
    std::vector<std::string> ::const_iterator _iter90;
    for (_iter90 = this->value.begin(); _iter90 != this->value.end(); ++_iter90)
    {
      xfer += oprot->writeString((*_iter90));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BulkStringRead &a, BulkStringRead &b) {
  using ::std::swap;
  swap(a.value, b.value);
  swap(a.status, b.status);
  swap(a.__isset, b.__isset);
}

BulkStringRead::BulkStringRead(const BulkStringRead& other91) {
  value = other91.value;
  status = other91.status;
  __isset = other91.__isset;
}
BulkStringRead& BulkStringRead::operator=(const BulkStringRead& other92) {
  value = other92.value;
  status = other92.status;
  __isset = other92.__isset;
  return *this;
}
void BulkStringRead::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BulkStringRead(";
  out << "value=" << to_string(value);
  out << ", " << "status=" << to_string(status);
  out << ")";
}


BooleanRead::~BooleanRead() throw() {
}


void BooleanRead::__set_value(const bool val) {
  this->value = val;
}

void BooleanRead::__set_status(const Status::type val) {
  this->status = val;
}
std::ostream& operator<<(std::ostream& out, const BooleanRead& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t BooleanRead::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast93;
          xfer += iprot->readI32(ecast93);
          this->status = (Status::type)ecast93;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BooleanRead::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BooleanRead");

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BooleanRead &a, BooleanRead &b) {
  using ::std::swap;
  swap(a.value, b.value);
  swap(a.status, b.status);
  swap(a.__isset, b.__isset);
}

BooleanRead::BooleanRead(const BooleanRead& other94) {
  value = other94.value;
  status = other94.status;
  __isset = other94.__isset;
}
BooleanRead& BooleanRead::operator=(const BooleanRead& other95) {
  value = other95.value;
  status = other95.status;
  __isset = other95.__isset;
  return *this;
}
void BooleanRead::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BooleanRead(";
  out << "value=" << to_string(value);
  out << ", " << "status=" << to_string(status);
  out << ")";
}


BulkBooleanRead::~BulkBooleanRead() throw() {
}


void BulkBooleanRead::__set_value(const std::vector<bool> & val) {
  this->value = val;
}

void BulkBooleanRead::__set_status(const Status::type val) {
  this->status = val;
}
std::ostream& operator<<(std::ostream& out, const BulkBooleanRead& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t BulkBooleanRead::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->value.clear();
            uint32_t _size96;
            ::apache::thrift::protocol::TType _etype99;
            xfer += iprot->readListBegin(_etype99, _size96);
            this->value.resize(_size96);
            uint32_t _i100;
            for (_i100 = 0; _i100 < _size96; ++_i100)
            {
              xfer += iprot->readBool(this->value[_i100]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast101;
          xfer += iprot->readI32(ecast101);
          this->status = (Status::type)ecast101;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BulkBooleanRead::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BulkBooleanRead");

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->value.size()));
    std::vector<bool> ::const_iterator _iter102;
    for (_iter102 = this->value.begin(); _iter102 != this->value.end(); ++_iter102)
    {
      xfer += oprot->writeBool((*_iter102));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BulkBooleanRead &a, BulkBooleanRead &b) {
  using ::std::swap;
  swap(a.value, b.value);
  swap(a.status, b.status);
  swap(a.__isset, b.__isset);
}

BulkBooleanRead::BulkBooleanRead(const BulkBooleanRead& other103) {
  value = other103.value;
  status = other103.status;
  __isset = other103.__isset;
}
BulkBooleanRead& BulkBooleanRead::operator=(const BulkBooleanRead& other104) {
  value = other104.value;
  status = other104.status;
  __isset = other104.__isset;
  return *this;
}
void BulkBooleanRead::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BulkBooleanRead(";
  out << "value=" << to_string(value);
  out << ", " << "status=" << to_string(status);
  out << ")";
}


Solver::~Solver() throw() {
}


void Solver::__set_name(const std::string& val) {
  this->name = val;
}

void Solver::__set_settings(const std::string& val) {
  this->settings = val;
}
std::ostream& operator<<(std::ostream& out, const Solver& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Solver::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->settings);
          this->__isset.settings = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Solver::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Solver");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("settings", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->settings);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Solver &a, Solver &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.settings, b.settings);
  swap(a.__isset, b.__isset);
}

Solver::Solver(const Solver& other105) {
  name = other105.name;
  settings = other105.settings;
  __isset = other105.__isset;
}
Solver& Solver::operator=(const Solver& other106) {
  name = other106.name;
  settings = other106.settings;
  __isset = other106.__isset;
  return *this;
}
void Solver::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Solver(";
  out << "name=" << to_string(name);
  out << ", " << "settings=" << to_string(settings);
  out << ")";
}


ModelDescription::~ModelDescription() throw() {
}


void ModelDescription::__set_fmiVersion(const std::string& val) {
  this->fmiVersion = val;
}

void ModelDescription::__set_modelName(const std::string& val) {
  this->modelName = val;
}

void ModelDescription::__set_guid(const std::string& val) {
  this->guid = val;
}

void ModelDescription::__set_license(const std::string& val) {
  this->license = val;
__isset.license = true;
}

void ModelDescription::__set_copyright(const std::string& val) {
  this->copyright = val;
__isset.copyright = true;
}

void ModelDescription::__set_author(const std::string& val) {
  this->author = val;
__isset.author = true;
}

void ModelDescription::__set_version(const std::string& val) {
  this->version = val;
__isset.version = true;
}

void ModelDescription::__set_description(const std::string& val) {
  this->description = val;
__isset.description = true;
}

void ModelDescription::__set_generationTool(const std::string& val) {
  this->generationTool = val;
__isset.generationTool = true;
}

void ModelDescription::__set_generationDateAndTime(const std::string& val) {
  this->generationDateAndTime = val;
__isset.generationDateAndTime = true;
}

void ModelDescription::__set_defaultExperiment(const DefaultExperiment& val) {
  this->defaultExperiment = val;
__isset.defaultExperiment = true;
}

void ModelDescription::__set_variableNamingConvention(const VariableNamingConvention::type val) {
  this->variableNamingConvention = val;
__isset.variableNamingConvention = true;
}

void ModelDescription::__set_modelVariables(const ModelVariables& val) {
  this->modelVariables = val;
}

void ModelDescription::__set_modelStructure(const ModelStructure& val) {
  this->modelStructure = val;
}

void ModelDescription::__set_supportsCoSimulation(const bool val) {
  this->supportsCoSimulation = val;
}

void ModelDescription::__set_supportsModelExchange(const bool val) {
  this->supportsModelExchange = val;
}
std::ostream& operator<<(std::ostream& out, const ModelDescription& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ModelDescription::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->fmiVersion);
          this->__isset.fmiVersion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->modelName);
          this->__isset.modelName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guid);
          this->__isset.guid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->license);
          this->__isset.license = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->copyright);
          this->__isset.copyright = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->author);
          this->__isset.author = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->description);
          this->__isset.description = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->generationTool);
          this->__isset.generationTool = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->generationDateAndTime);
          this->__isset.generationDateAndTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->defaultExperiment.read(iprot);
          this->__isset.defaultExperiment = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast107;
          xfer += iprot->readI32(ecast107);
          this->variableNamingConvention = (VariableNamingConvention::type)ecast107;
          this->__isset.variableNamingConvention = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->modelVariables.clear();
            uint32_t _size108;
            ::apache::thrift::protocol::TType _etype111;
            xfer += iprot->readListBegin(_etype111, _size108);
            this->modelVariables.resize(_size108);
            uint32_t _i112;
            for (_i112 = 0; _i112 < _size108; ++_i112)
            {
              xfer += this->modelVariables[_i112].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.modelVariables = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->modelStructure.read(iprot);
          this->__isset.modelStructure = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->supportsCoSimulation);
          this->__isset.supportsCoSimulation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->supportsModelExchange);
          this->__isset.supportsModelExchange = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ModelDescription::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ModelDescription");

  xfer += oprot->writeFieldBegin("fmiVersion", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->fmiVersion);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("modelName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->modelName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->guid);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.license) {
    xfer += oprot->writeFieldBegin("license", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->license);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.copyright) {
    xfer += oprot->writeFieldBegin("copyright", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->copyright);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.author) {
    xfer += oprot->writeFieldBegin("author", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->author);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.version) {
    xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.description) {
    xfer += oprot->writeFieldBegin("description", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->description);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.generationTool) {
    xfer += oprot->writeFieldBegin("generationTool", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->generationTool);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.generationDateAndTime) {
    xfer += oprot->writeFieldBegin("generationDateAndTime", ::apache::thrift::protocol::T_STRING, 10);
    xfer += oprot->writeString(this->generationDateAndTime);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.defaultExperiment) {
    xfer += oprot->writeFieldBegin("defaultExperiment", ::apache::thrift::protocol::T_STRUCT, 11);
    xfer += this->defaultExperiment.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.variableNamingConvention) {
    xfer += oprot->writeFieldBegin("variableNamingConvention", ::apache::thrift::protocol::T_I32, 12);
    xfer += oprot->writeI32((int32_t)this->variableNamingConvention);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("modelVariables", ::apache::thrift::protocol::T_LIST, 13);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->modelVariables.size()));
    std::vector<ScalarVariable> ::const_iterator _iter113;
    for (_iter113 = this->modelVariables.begin(); _iter113 != this->modelVariables.end(); ++_iter113)
    {
      xfer += (*_iter113).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("modelStructure", ::apache::thrift::protocol::T_STRUCT, 14);
  xfer += this->modelStructure.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("supportsCoSimulation", ::apache::thrift::protocol::T_BOOL, 15);
  xfer += oprot->writeBool(this->supportsCoSimulation);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("supportsModelExchange", ::apache::thrift::protocol::T_BOOL, 16);
  xfer += oprot->writeBool(this->supportsModelExchange);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ModelDescription &a, ModelDescription &b) {
  using ::std::swap;
  swap(a.fmiVersion, b.fmiVersion);
  swap(a.modelName, b.modelName);
  swap(a.guid, b.guid);
  swap(a.license, b.license);
  swap(a.copyright, b.copyright);
  swap(a.author, b.author);
  swap(a.version, b.version);
  swap(a.description, b.description);
  swap(a.generationTool, b.generationTool);
  swap(a.generationDateAndTime, b.generationDateAndTime);
  swap(a.defaultExperiment, b.defaultExperiment);
  swap(a.variableNamingConvention, b.variableNamingConvention);
  swap(a.modelVariables, b.modelVariables);
  swap(a.modelStructure, b.modelStructure);
  swap(a.supportsCoSimulation, b.supportsCoSimulation);
  swap(a.supportsModelExchange, b.supportsModelExchange);
  swap(a.__isset, b.__isset);
}

ModelDescription::ModelDescription(const ModelDescription& other114) {
  fmiVersion = other114.fmiVersion;
  modelName = other114.modelName;
  guid = other114.guid;
  license = other114.license;
  copyright = other114.copyright;
  author = other114.author;
  version = other114.version;
  description = other114.description;
  generationTool = other114.generationTool;
  generationDateAndTime = other114.generationDateAndTime;
  defaultExperiment = other114.defaultExperiment;
  variableNamingConvention = other114.variableNamingConvention;
  modelVariables = other114.modelVariables;
  modelStructure = other114.modelStructure;
  supportsCoSimulation = other114.supportsCoSimulation;
  supportsModelExchange = other114.supportsModelExchange;
  __isset = other114.__isset;
}
ModelDescription& ModelDescription::operator=(const ModelDescription& other115) {
  fmiVersion = other115.fmiVersion;
  modelName = other115.modelName;
  guid = other115.guid;
  license = other115.license;
  copyright = other115.copyright;
  author = other115.author;
  version = other115.version;
  description = other115.description;
  generationTool = other115.generationTool;
  generationDateAndTime = other115.generationDateAndTime;
  defaultExperiment = other115.defaultExperiment;
  variableNamingConvention = other115.variableNamingConvention;
  modelVariables = other115.modelVariables;
  modelStructure = other115.modelStructure;
  supportsCoSimulation = other115.supportsCoSimulation;
  supportsModelExchange = other115.supportsModelExchange;
  __isset = other115.__isset;
  return *this;
}
void ModelDescription::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ModelDescription(";
  out << "fmiVersion=" << to_string(fmiVersion);
  out << ", " << "modelName=" << to_string(modelName);
  out << ", " << "guid=" << to_string(guid);
  out << ", " << "license="; (__isset.license ? (out << to_string(license)) : (out << "<null>"));
  out << ", " << "copyright="; (__isset.copyright ? (out << to_string(copyright)) : (out << "<null>"));
  out << ", " << "author="; (__isset.author ? (out << to_string(author)) : (out << "<null>"));
  out << ", " << "version="; (__isset.version ? (out << to_string(version)) : (out << "<null>"));
  out << ", " << "description="; (__isset.description ? (out << to_string(description)) : (out << "<null>"));
  out << ", " << "generationTool="; (__isset.generationTool ? (out << to_string(generationTool)) : (out << "<null>"));
  out << ", " << "generationDateAndTime="; (__isset.generationDateAndTime ? (out << to_string(generationDateAndTime)) : (out << "<null>"));
  out << ", " << "defaultExperiment="; (__isset.defaultExperiment ? (out << to_string(defaultExperiment)) : (out << "<null>"));
  out << ", " << "variableNamingConvention="; (__isset.variableNamingConvention ? (out << to_string(variableNamingConvention)) : (out << "<null>"));
  out << ", " << "modelVariables=" << to_string(modelVariables);
  out << ", " << "modelStructure=" << to_string(modelStructure);
  out << ", " << "supportsCoSimulation=" << to_string(supportsCoSimulation);
  out << ", " << "supportsModelExchange=" << to_string(supportsModelExchange);
  out << ")";
}

}} // namespace
